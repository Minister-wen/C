# 运算符与表达式

## 常用的运算符种类

| **运算符类型** | **作用**                               |
| -------------- | -------------------------------------- |
| 算术运算符     | 用于处理四则运算                       |
| 赋值运算符     | 用于将表达式的值赋给变量               |
| 比较运算符     | 用于表达式的比较，并返回一个真值或假值 |
| 逻辑运算符     | 用于根据表达式的值返回真值或假值       |
| 位运算符       | 用于处理数据的位运算                   |
| sizeof运算符   | 用于求字节数长度                       |

整形和整形运算结果是整型

double f是先进行计算，然后进行赋值，计算完就是0了

但是运算中如果类型不一样，结果依照最大的类型来，也就是a 和b至少有一个是double类型，结果就是double类型

经过操作，运算乘0.1表示结果转化为double类型，然后运算结果就表示为double类型

```c
int a = 10;
int b = 20;
int c = b/a; //2
int d = a/b  //0---只保留整数部分，不保留小数部分

//两数相除，如果要得到小数，必须有一个是double类型，或者float类型
double f = a/b; //0.000000 默认六位  
double h = a*0.1/b// 0.500000
    
```

C语言中除数不能为0，否则会报错 a/0

取余：

```c
int a=2;
int b=3;
int c = a%b; 
```

求一个数的个十百千位

```c
a = 1234
int b = num%10 个位
int c = num/10%10 十位
int d = num/100%10 百位
int d = num/1000%10 千位
```



## 自增，自减

a++ ++a 作用域只在   当前语句                有可能有区别，过了这个语句就不会影响其他的语句了

单独使用，效果相同 a = a+1

如果表达式，++在后，先其他表达式，再自加

如果++在前，先自加，再其他表达式

注意，一条；的语句进行一次自加，printf也满足这个要求，但是一旦跨；号了，就不用考虑那么多了，只需要考虑当前语句的自加情况

```c
int a = 1
int b = 0;
b=a++
printf("b=%d a=%d\n",b,a); //1 2

int a = 1
int b = 0;
b=++a
printf("b=%d a=%d\n",b,a); //2 2

c = 2;
printf("c=%d",c++);//2
c = 2;
printf("c=%d",++c);//3
```


```
arr[0]=0;
arr[1]=1;
arr[2]=2;
arr[3]=3;
arr[4] =4;
arr[5]=5;

a = 1
arr[a++]= arr[++a]+arr[a++] 
0
1
4
3
4
5
a=1
arr[++a] = arr[a++]+arr[++a] 


arr[0]=;
arr[1]=;
arr[2]=;
arr[3]=;
arr[4] =;
arr[5]=5;


```





比较运算符比较的结果一定是bool，真用数字1，假用数字0表示%d

C语言中0为假，1为真，bool和0和1是一个概念

C语言中==非0为真==，0为假



A&&B表达式

如果A表达式为假，B表达式不执行



如果A||B前面为1，后面也不执行

```C
int a=1;
printf("%d\n",!a);0
printf("%d\n",!0); 1
printf("%d\n",!-1); 0
    
int a = 0;
int b=1;

printf("%d\n",a&&b++);
prinf("a=%d, b=%d",a,b);
0
a=0, b=1
为什么第二个b为1，因为&&一假全假，如果第一个为0，第二个根本不执行，所以b的值不变，b++根本不执行
int a = 0;
int b=1;
printf("%d\n",b++&&a);
prinf("a=%d, b=%d",a,b);
0
0
a=0, b=2
和前后顺序有关系，执行顺序是从左向右的，故先执行b++，然后判断与

int a = 0;
int b=1;
printf("%d\n", b++|| a++);
printf("a=%d, b=%d", a, b);
a=0,b=2
如果A||B前面为1，后面也不执行
```





# 运算符优先级

c+++b++c+

C+++b   c++  +b先使用，再加

c=0,b=2



相同优先级，看方向



逗号运算符：值是最后一个表达式的结果

int a = 1,

int b = 2.

int c = (a++,b++,10,200,a+b);

int a = 2, b =3

c =5

## 数据的类型转换

##### 1. 数据有不同的类型，不同类型数据之间进行混合运算时必然涉及到类型的转换问题。

##### 2. 转换的方式：

* 隐式转换（自动转换）：遵循一定的规则，由编译系统自动完成
* 强制类型转换：把表达式的运算结果强制转换成所需要的数据类型
* 

强制转换：（目标类型）原来的数据

一般所有的都转换，等号两端如果类型不匹配，尽量进行转换

```C
int a = 3;
double b = a;  // 这一步发生了自动的类型转换，这一步叫做隐式转换
printf("%lf",b)//3.000000
    
printf("%d\n",3.14);//这时候不能直接转换，
那么就需要强制的类型转换：当所需要的类型和要求的类型不匹配，就需要强制的类型匹配
printf("%d\n",(int)3.14)
    
printf("%lf\n",a)//类型不匹配，结果有误
printf("%lf\n",(double)a)  //需要强制转换

```





强制转换的宗旨：数据不可以丢失

